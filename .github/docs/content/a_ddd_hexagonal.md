<!-- markdownlint-disable MD024 -->

# Guia de Arquitetura DDD e Hexagonal (Sistemas de Pagamento)

> [Voltar](../../../README.md)

## √çndice

- [Guia de Arquitetura DDD e Hexagonal (Sistemas de Pagamento)](#guia-de-arquitetura-ddd-e-hexagonal-sistemas-de-pagamento)
  - [√çndice](#√≠ndice)
  - [1. ENTITIES (Entidades)](#1-entities-entidades)
    - [Para uma crian√ßa de 5 anos](#para-uma-crian√ßa-de-5-anos)
    - [Para um estudante](#para-um-estudante)
    - [Para um programador profissional](#para-um-programador-profissional)
    - [Exemplo em TypeScript: Entidade Transaction (Transa√ß√£o)](#exemplo-em-typescript-entidade-transaction-transa√ß√£o)
  - [2. VALUE OBJECTS (Objetos de Valor)](#2-value-objects-objetos-de-valor)
    - [Para uma crian√ßa de 5 anos](#para-uma-crian√ßa-de-5-anos-1)
    - [Para um estudante](#para-um-estudante-1)
    - [Para um programador profissional](#para-um-programador-profissional-1)
    - [Exemplo em TypeScript: Value Objects para Sistema de Pagamento](#exemplo-em-typescript-value-objects-para-sistema-de-pagamento)
  - [3. AGREGADOS (Aggregates)](#3-agregados-aggregates)
    - [Para uma crian√ßa de 5 anos](#para-uma-crian√ßa-de-5-anos-2)
    - [Para um estudante](#para-um-estudante-2)
    - [Para um programador profissional](#para-um-programador-profissional-2)
    - [Exemplo em TypeScript: Agregado Payment (Pagamento)](#exemplo-em-typescript-agregado-payment-pagamento)
  - [4. REPOSITORY](#4-repository)
    - [Para uma crian√ßa de 5 anos üßí](#para-uma-crian√ßa-de-5-anos-)
    - [Para um estudante üéì](#para-um-estudante-)
    - [Para um programador profissional üë®‚Äçüíº](#para-um-programador-profissional-)
    - [Exemplo em TypeScript: Payment Repository](#exemplo-em-typescript-payment-repository)
  - [5. USE CASES (Casos de Uso)](#5-use-cases-casos-de-uso)
    - [Para uma crian√ßa de 5 anos üßí](#para-uma-crian√ßa-de-5-anos--1)
    - [Para um estudante üéì](#para-um-estudante--1)
    - [Para um programador profissional üë®‚Äçüíº](#para-um-programador-profissional--1)
    - [Exemplo em TypeScript: Create Payment Use Case](#exemplo-em-typescript-create-payment-use-case)
  - [6. SERVICES (Servi√ßos de Dom√≠nio)](#6-services-servi√ßos-de-dom√≠nio)
    - [Para uma crian√ßa de 5 anos üßí](#para-uma-crian√ßa-de-5-anos--2)
    - [Para um estudante üéì](#para-um-estudante--2)
    - [Para um programador profissional üë®‚Äçüíº](#para-um-programador-profissional--2)
    - [Exemplo em TypeScript: Domain Services](#exemplo-em-typescript-domain-services)
  - [7. CONTROLLERS](#7-controllers)
    - [Para uma crian√ßa de 5 anos üßí](#para-uma-crian√ßa-de-5-anos--3)
    - [Para um estudante üéì](#para-um-estudante--3)
    - [Para um programador profissional üë®‚Äçüíº](#para-um-programador-profissional--3)
    - [Exemplo em TypeScript: Controllers para Pagamentos](#exemplo-em-typescript-controllers-para-pagamentos)
  - [8. ADAPTERS (Adaptadores)](#8-adapters-adaptadores)
    - [Para uma crian√ßa de 5 anos üßí](#para-uma-crian√ßa-de-5-anos--4)
    - [Para um estudante üéì](#para-um-estudante--4)
    - [Para um programador profissional üë®‚Äçüíº](#para-um-programador-profissional--4)
    - [Exemplo em TypeScript: Adapters de Entrada e Sa√≠da](#exemplo-em-typescript-adapters-de-entrada-e-sa√≠da)
  - [9. INTERFACES (Contratos)](#9-interfaces-contratos)
    - [Para uma crian√ßa de 5 anos üßí](#para-uma-crian√ßa-de-5-anos--5)
    - [Para um estudante üéì](#para-um-estudante--5)
    - [Para um programador profissional üë®‚Äçüíº](#para-um-programador-profissional--5)
    - [Exemplo em TypeScript: Interfaces e Contratos](#exemplo-em-typescript-interfaces-e-contratos)
  - [üìä DIAGRAMA GERAL: ARQUITETURA HEXAGONAL COM DDD](#-diagrama-geral-arquitetura-hexagonal-com-ddd)
  - [FLUXO DE UMA REQUISI√á√ÉO](#fluxo-de-uma-requisi√ß√£o)
  - [ESTRUTURA DE PASTAS RECOMENDADA](#estrutura-de-pastas-recomendada)
  - [EXEMPLO COMPLETO: CRIAR E PROCESSAR PAGAMENTO](#exemplo-completo-criar-e-processar-pagamento)
  - [üß™ TESTES UNIT√ÅRIOS COM MOCKS](#-testes-unit√°rios-com-mocks)
  - [RESUMO: COMO OS CONCEITOS TRABALHAM JUNTOS](#resumo-como-os-conceitos-trabalham-juntos)
  - [BENEF√çCIOS DESSA ARQUITETURA](#benef√≠cios-dessa-arquitetura)
  - [üìö REFER√äNCIAS E PR√ìXIMOS PASSOS](#-refer√™ncias-e-pr√≥ximos-passos)
    - [Conceitos avan√ßados a explorar](#conceitos-avan√ßados-a-explorar)
    - [Padr√µes complementares](#padr√µes-complementares)
  - [CONCLUS√ÉO](#conclus√£o)

---

## 1. ENTITIES (Entidades)

### Para uma crian√ßa de 5 anos

Uma entidade √© como um personagem em um livro de hist√≥rias. Cada personagem tem um nome especial que nunca muda (mesmo que fique mais velho), e essa √© sua identidade. O personagem pode mudar de roupa, ficar mais alto, mas continua sendo a mesma pessoa. Uma entidade √© assim: tem um identificador √∫nico (como seu nome) e pode mudar de outras formas, mas continua sendo ela mesma.

### Para um estudante

Uma entidade √© um objeto do dom√≠nio que possui identidade √∫nica e cont√≠nuidade ao longo de seu ciclo de vida. Diferentemente de um Value Object, a entidade √© identificada por um identificador √∫nico (ID) e n√£o pela igualdade de seus atributos. Duas entidades com os mesmos atributos continuam sendo entidades diferentes se tiverem IDs diferentes. Entidades encapsulam comportamento e estado relacionados a um conceito importante do neg√≥cio.

### Para um programador profissional

Uma Entidade em DDD √© um objeto fundamental do modelo de dom√≠nio caracterizado pela identidade √∫nica e pela continuidade de sua vida √∫til. Entidades possuem um identificador que as diferencia de outras inst√¢ncias, independentemente de seus atributos. Elas encapsulam tanto estado quanto comportamento, permitindo que regras de neg√≥cio importantes sejam expressas atrav√©s de m√©todos. A igualdade entre entidades √© baseada em identidade, n√£o em valor, distinguindo-as fundamentalmente de Value Objects.

### Exemplo em TypeScript: Entidade Transaction (Transa√ß√£o)

```typescript
// Dom√≠nio - Transaction √© uma Entidade
export class Transaction {
  // Identificador √∫nico - define a identidade
  private readonly _id: TransactionId;
  
  // Estado mut√°vel
  private _amount: Money;
  private _status: TransactionStatus;
  private _createdAt: Date;
  private _updatedAt: Date;
  
  constructor(
    id: TransactionId,
    amount: Money,
    status: TransactionStatus,
  ) {
    this._id = id;
    this._amount = amount;
    this._status = status;
    this._createdAt = new Date();
    this._updatedAt = new Date();
  }
  
  // Getter para o identificador √∫nico
  get id(): TransactionId {
    return this._id;
  }
  
  get amount(): Money {
    return this._amount;
  }
  
  get status(): TransactionStatus {
    return this._status;
  }
  
  // Comportamento de neg√≥cio
  approve(): void {
    if (this._status !== TransactionStatus.PENDING) {
      throw new Error('Only pending transactions can be approved');
    }
    this._status = TransactionStatus.APPROVED;
    this._updatedAt = new Date();
  }
  
  reject(reason: string): void {
    if (this._status !== TransactionStatus.PENDING) {
      throw new Error('Only pending transactions can be rejected');
    }
    this._status = TransactionStatus.REJECTED;
    this._updatedAt = new Date();
  }
  
  // Igualdade baseada em identidade, n√£o em valor
  equals(other: Transaction): boolean {
    return this._id.equals(other._id);
  }
}

export enum TransactionStatus {
  PENDING = 'PENDING',
  APPROVED = 'APPROVED',
  REJECTED = 'REJECTED',
  COMPLETED = 'COMPLETED',
}
```

---

## 2. VALUE OBJECTS (Objetos de Valor)

### Para uma crian√ßa de 5 anos

Um Value Object √© como uma moeda. Se voc√™ tem duas moedas de R$10, elas s√£o iguais, n√£o importa qual voc√™ pegar. O que importa √© o valor da moeda, n√£o qual moeda espec√≠fica voc√™ tem. Se uma moeda for diferente em qualquer coisa, a√≠ n√£o √© mais igual.

### Para um estudante

Um Value Object √© um objeto imut√°vel do dom√≠nio cuja igualdade √© baseada no valor de todos os seus atributos, n√£o em uma identidade √∫nica. Diferentemente das Entidades, dois Value Objects com os mesmos atributos s√£o considerados iguais. Value Objects n√£o possuem um identificador √∫nico e, uma vez criados, n√£o podem ser modificados. Eles s√£o usados para expressar conceitos simples mas importantes do neg√≥cio de forma segura e clara.

### Para um programador profissional

Um Value Object em DDD √© um objeto imut√°vel cujos atributos definem completamente sua identidade. Objetos de valor n√£o possuem identidade √∫nica; sua igualdade √© determinada pela igualdade de seus atributos. Devem ser imut√°veis para garantir que mudan√ßas no estado levem √† cria√ß√£o de novas inst√¢ncias. Value Objects s√£o especialmente √∫teis para encapsular conceitos de neg√≥cio simples (como dinheiro, endere√ßo, email) e para valida√ß√£o de invariantes.

### Exemplo em TypeScript: Value Objects para Sistema de Pagamento

```typescript
// Money √© um Value Object - representa quantidade de moeda
export class Money {
  private readonly _amount: number;
  private readonly _currency: string;
  
  constructor(amount: number, currency: string = 'BRL') {
    // Valida√ß√£o de invariante
    if (amount < 0) {
      throw new Error('Amount cannot be negative');
    }
    if (!currency || currency.length !== 3) {
      throw new Error('Currency must be a valid 3-letter code');
    }
    this._amount = amount;
    this._currency = currency;
  }
  
  get amount(): number {
    return this._amount;
  }
  
  get currency(): string {
    return this._currency;
  }
  
  // Opera√ß√µes retornam novos Value Objects (imutabilidade)
  add(other: Money): Money {
    if (this._currency !== other._currency) {
      throw new Error('Cannot add different currencies');
    }
    return new Money(this._amount + other._amount, this._currency);
  }
  
  subtract(other: Money): Money {
    if (this._currency !== other._currency) {
      throw new Error('Cannot subtract different currencies');
    }
    return new Money(this._amount - other._amount, this._currency);
  }
  
  // Igualdade por valor
  equals(other: Money): boolean {
    return (
      this._amount === other._amount &&
      this._currency === other._currency
    );
  }
  
  isGreaterThan(other: Money): boolean {
    if (this._currency !== other._currency) {
      throw new Error('Cannot compare different currencies');
    }
    return this._amount > other._amount;
  }
}

// Email √© um Value Object
export class Email {
  private readonly _value: string;
  
  constructor(value: string) {
    // Valida√ß√£o com regex simples
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      throw new Error('Invalid email format');
    }
    this._value = value.toLowerCase();
  }
  
  get value(): string {
    return this._value;
  }
  
  equals(other: Email): boolean {
    return this._value === other._value;
  }
}

// TransactionId √© um Value Object que encapsula o identificador
export class TransactionId {
  private readonly _value: string;
  
  constructor(value: string) {
    if (!value || value.trim().length === 0) {
      throw new Error('TransactionId cannot be empty');
    }
    this._value = value;
  }
  
  get value(): string {
    return this._value;
  }
  
  equals(other: TransactionId): boolean {
    return this._value === other._value;
  }
}
```

---

## 3. AGREGADOS (Aggregates)

### Para uma crian√ßa de 5 anos

Um agregado √© como uma caixa com v√°rios brinquedos dentro. H√° um brinquedo especial que √© o "chefe" da caixa (a raiz do agregado). Se voc√™ quer mexer com os brinquedos, voc√™ s√≥ fala com o chefe. O chefe cuida de todos os outros brinquedos e garante que tudo fica bem organizado.

### Para um estudante

Um Agregado √© um cluster de objetos de dom√≠nio (Entidades e Value Objects) que devem ser tratados como uma unidade √∫nica. Existe uma Entidade raiz (Aggregate Root) que controla o acesso aos outros objetos do agregado. Invariantes de neg√≥cio s√£o garantidas apenas no n√≠vel do agregado. Comunica√ß√£o entre agregados acontece apenas atrav√©s das ra√≠zes de agregados, mantendo consist√™ncia transacional e facilitando a compreens√£o do modelo.

### Para um programador profissional

Um Agregado em DDD √© um padr√£o de design que agrupa Entidades e Value Objects em torno de uma Aggregate Root. A raiz √© a √∫nica entidade do agregado acess√≠vel do exterior; acesso aos outros objetos acontece apenas atrav√©s dela. Agregados estabelece limites de consist√™ncia: invariantes de neg√≥cio s√£o mantidas atomicamente no n√≠vel do agregado. Transa√ß√µes devem afetam apenas um agregado por vez, facilitando escalabilidade e clareza sem√¢ntica. Agregados comunicam-se atrav√©s de identidades, n√£o refer√™ncias diretas.

### Exemplo em TypeScript: Agregado Payment (Pagamento)

```typescript
// Aggregate Root - Payment controla todo o agregado
export class Payment {
  private readonly _id: PaymentId;
  private readonly _accountId: AccountId;
  private _amount: Money;
  private _status: PaymentStatus;
  private readonly _transactions: Transaction[] = [];
  private _createdAt: Date;
  private _updatedAt: Date;
  
  constructor(
    id: PaymentId,
    accountId: AccountId,
    amount: Money,
  ) {
    // Valida√ß√£o de invariantes do agregado
    if (amount.amount <= 0) {
      throw new Error('Payment amount must be positive');
    }
    
    this._id = id;
    this._accountId = accountId;
    this._amount = amount;
    this._status = PaymentStatus.PENDING;
    this._createdAt = new Date();
    this._updatedAt = new Date();
  }
  
  get id(): PaymentId {
    return this._id;
  }
  
  get accountId(): AccountId {
    return this._accountId;
  }
  
  get amount(): Money {
    return this._amount;
  }
  
  get status(): PaymentStatus {
    return this._status;
  }
  
  // Acesso read-only √†s transa√ß√µes
  get transactions(): ReadonlyArray<Transaction> {
    return Object.freeze([...this._transactions]);
  }
  
  // Opera√ß√£o do agregado: adicionar transa√ß√£o
  addTransaction(transaction: Transaction): void {
    // Invariante: s√≥ pode adicionar transa√ß√µes a pagamentos pendentes
    if (this._status !== PaymentStatus.PENDING) {
      throw new Error('Cannot add transactions to non-pending payments');
    }
    
    // Invariante: transa√ß√£o n√£o pode estar duplicada
    if (this._transactions.some(t => t.equals(transaction))) {
      throw new Error('Transaction already added to this payment');
    }
    
    this._transactions.push(transaction);
    this._updatedAt = new Date();
  }
  
  // Opera√ß√£o do agregado: processar pagamento
  process(): void {
    if (this._transactions.length === 0) {
      throw new Error('Cannot process payment without transactions');
    }
    
    if (this._status !== PaymentStatus.PENDING) {
      throw new Error('Only pending payments can be processed');
    }
    
    this._status = PaymentStatus.PROCESSING;
    this._updatedAt = new Date();
  }
  
  // Opera√ß√£o do agregado: confirmar pagamento
  confirm(): void {
    if (this._status !== PaymentStatus.PROCESSING) {
      throw new Error('Only processing payments can be confirmed');
    }
    
    // Invariante: todas as transa√ß√µes devem estar aprovadas
    const allApproved = this._transactions.every(
      t => t.status === TransactionStatus.APPROVED
    );
    
    if (!allApproved) {
      throw new Error('Not all transactions are approved');
    }
    
    this._status = PaymentStatus.COMPLETED;
    this._updatedAt = new Date();
  }
  
  // Opera√ß√£o do agregado: rejeitar pagamento
  reject(reason: string): void {
    if (this._status === PaymentStatus.COMPLETED || 
        this._status === PaymentStatus.REJECTED) {
      throw new Error('Cannot reject a completed or already rejected payment');
    }
    
    this._status = PaymentStatus.REJECTED;
    this._updatedAt = new Date();
  }
  
  equals(other: Payment): boolean {
    return this._id.equals(other._id);
  }
}

export enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  COMPLETED = 'COMPLETED',
  REJECTED = 'REJECTED',
}

// Tipos de identificadores para os agregados
export class PaymentId {
  constructor(private readonly value: string) {
    if (!value) throw new Error('PaymentId cannot be empty');
  }
  
  equals(other: PaymentId): boolean {
    return this.value === other.value;
  }
}

export class AccountId {
  constructor(private readonly value: string) {
    if (!value) throw new Error('AccountId cannot be empty');
  }
  
  equals(other: AccountId): boolean {
    return this.value === other.value;
  }
}
```

---

## 4. REPOSITORY

### Para uma crian√ßa de 5 anos üßí

Um Repository √© como a biblioteca da sua escola. Quando voc√™ quer um livro, vai at√© a bibliotec√°ria e pede. Voc√™ n√£o precisa saber onde exatamente o livro est√° guardado, s√≥ diz o nome e ela acha para voc√™. O Repository funciona assim: voc√™ pede dados e ele traz, sem voc√™ precisar saber se est√£o num arquivo, num banco de dados ou em outro lugar qualquer.

### Para um estudante üéì

Um Repository √© um padr√£o que abstrai a persist√™ncia de agregados. Atua como uma cole√ß√£o em mem√≥ria simulada, fornecendo m√©todos para adicionar, remover e recuperar agregados. O Repository encapsula toda a l√≥gica de acesso ao banco de dados, permitindo que o dom√≠nio n√£o tenha depend√™ncia com detalhes de infraestrutura. Do ponto de vista do dom√≠nio, trabalha-se com agregados, n√£o com tabelas ou consultas SQL.

### Para um programador profissional üë®‚Äçüíº

Um Repository em DDD implementa o padr√£o Repository, servindo como um intermedi√°rio entre a camada de dom√≠nio e a camada de infraestrutura. Encapsula a l√≥gica de persist√™ncia de agregados, oferecendo uma abstra√ß√£o que apresenta agregados como uma cole√ß√£o em mem√≥ria. Implementa√ß√µes espec√≠ficas (SQL, NoSQL, etc.) ficam isoladas, permitindo testes e mudan√ßas sem afetar o dom√≠nio. Repositories trabalham com agregados inteiros, n√£o com entidades individuais, garantindo consist√™ncia.

### Exemplo em TypeScript: Payment Repository

```typescript
// Contrato do Repository - definido no dom√≠nio
export interface IPaymentRepository {
  save(payment: Payment): Promise<void>;
  findById(id: PaymentId): Promise<Payment | null>;
  delete(id: PaymentId): Promise<void>;
}

// Implementa√ß√£o em infraestrutura - com banco de dados
export class PaymentRepositorySQL implements IPaymentRepository {
  constructor(private readonly database: DatabaseConnection) {}
  
  async save(payment: Payment): Promise<void> {
    // Converter agregado para estrutura de dados persist√≠vel
    const paymentData = {
      id: payment.id.value,
      accountId: payment.accountId.value,
      amount: payment.amount.amount,
      currency: payment.amount.currency,
      status: payment.status,
      createdAt: payment.createdAt,
      updatedAt: payment.updatedAt,
    };
    
    // Salvar no banco de dados
    await this.database.query(
      `INSERT INTO payments (id, account_id, amount, currency, status, created_at, updated_at) 
       VALUES (?, ?, ?, ?, ?, ?, ?)
       ON DUPLICATE KEY UPDATE 
       status = ?, updated_at = ?`,
      [
        paymentData.id,
        paymentData.accountId,
        paymentData.amount,
        paymentData.currency,
        paymentData.status,
        paymentData.createdAt,
        paymentData.updatedAt,
        paymentData.status,
        paymentData.updatedAt,
      ]
    );
    
    // Salvar transa√ß√µes associadas
    for (const transaction of payment.transactions) {
      await this.database.query(
        `INSERT INTO transactions (id, payment_id, amount, currency, status, created_at)
         VALUES (?, ?, ?, ?, ?, ?)`,
        [
          transaction.id.value,
          payment.id.value,
          transaction.amount.amount,
          transaction.amount.currency,
          transaction.status,
          transaction.createdAt,
        ]
      );
    }
  }
  
  async findById(id: PaymentId): Promise<Payment | null> {
    // Buscar pagamento no banco
    const paymentRow = await this.database.queryOne(
      'SELECT * FROM payments WHERE id = ?',
      [id.value]
    );
    
    if (!paymentRow) {
      return null;
    }
    
    // Buscar transa√ß√µes associadas
    const transactionRows = await this.database.query(
      'SELECT * FROM transactions WHERE payment_id = ?',
      [id.value]
    );
    
    // Reconstruir o agregado a partir dos dados
    const payment = new Payment(
      new PaymentId(paymentRow.id),
      new AccountId(paymentRow.account_id),
      new Money(paymentRow.amount, paymentRow.currency)
    );
    
    // Restaurar estado do pagamento
    (payment as any)._status = paymentRow.status;
    (payment as any)._createdAt = paymentRow.created_at;
    (payment as any)._updatedAt = paymentRow.updated_at;
    
    // Restaurar transa√ß√µes
    for (const txRow of transactionRows) {
      const transaction = new Transaction(
        new TransactionId(txRow.id),
        new Money(txRow.amount, txRow.currency),
        txRow.status
      );
      payment.addTransaction(transaction);
    }
    
    return payment;
  }
  
  async delete(id: PaymentId): Promise<void> {
    await this.database.query(
      'DELETE FROM payments WHERE id = ?',
      [id.value]
    );
  }
}

// Implementa√ß√£o com armazenamento em mem√≥ria para testes
export class PaymentRepositoryMemory implements IPaymentRepository {
  private payments: Map<string, Payment> = new Map();
  
  async save(payment: Payment): Promise<void> {
    this.payments.set(payment.id.value, payment);
  }
  
  async findById(id: PaymentId): Promise<Payment | null> {
    return this.payments.get(id.value) || null;
  }
  
  async delete(id: PaymentId): Promise<void> {
    this.payments.delete(id.value);
  }
}
```

---

## 5. USE CASES (Casos de Uso)

### Para uma crian√ßa de 5 anos üßí

Um Use Case √© como um passo-a-passo de como fazer algo. Se voc√™ quer brincar no escorregador, o Use Case √©: 1) chegar ao parque, 2) subir na escada, 3) sentar e escorregar, 4) correr e fazer de novo. Um Use Case no software √© assim: uma sequ√™ncia de passos que o usu√°rio segue para fazer algo importante no sistema.

### Para um estudante üéì

Um Use Case √© um componente da l√≥gica de aplica√ß√£o que coordena a intera√ß√£o entre o usu√°rio, o dom√≠nio e a infraestrutura. Ele representa um fluxo espec√≠fico de neg√≥cio, orquestrando as opera√ß√µes necess√°rias para completar uma a√ß√£o do usu√°rio. Use Cases recebem input, utilizam reposit√≥rios para acessar agregados, executam opera√ß√µes de dom√≠nio e persistem mudan√ßas. Cada Use Case √© respons√°vel por um √∫nico cen√°rio de neg√≥cio bem definido.

### Para um programador profissional üë®‚Äçüíº

Um Use Case em arquitetura limpa √© um orchestrador de l√≥gica de aplica√ß√£o que coordena intera√ß√µes entre camadas. Recebe input padronizado (request), executa opera√ß√µes de dom√≠nio utilizando repositories e services, e retorna output padronizado (response). Use Cases implementam fluxos de neg√≥cio espec√≠ficos, mantendo-se independentes de detalhes de UI ou persist√™ncia. S√£o test√°veis, reutiliz√°veis e expressam a inten√ß√£o do neg√≥cio de forma clara.

### Exemplo em TypeScript: Create Payment Use Case

```typescript
// Input do Use Case (Data Transfer Object)
export interface CreatePaymentInput {
  accountId: string;
  amount: number;
  currency: string;
}

// Output do Use Case
export interface CreatePaymentOutput {
  paymentId: string;
  status: string;
  amount: number;
  currency: string;
}

// Use Case - coordena dom√≠nio e infraestrutura
export class CreatePaymentUseCase {
  constructor(
    private readonly paymentRepository: IPaymentRepository,
    private readonly paymentService: PaymentService,
    private readonly logger: Logger,
  ) {}
  
  async execute(input: CreatePaymentInput): Promise<CreatePaymentOutput> {
    try {
      // Valida√ß√£o de entrada
      if (!input.accountId || input.amount <= 0) {
        throw new Error('Invalid input: accountId and positive amount required');
      }
      
      this.logger.info('Creating payment', { accountId: input.accountId, amount: input.amount });
      
      // Criar agregado usando Value Objects
      const paymentId = new PaymentId(this.generateId());
      const accountId = new AccountId(input.accountId);
      const amount = new Money(input.amount, input.currency);
      
      // Criar agregado no dom√≠nio
      const payment = new Payment(paymentId, accountId, amount);
      
      // Usar servi√ßo de dom√≠nio se necess√°rio
      // (exemplo: validar limite de conta, aplicar regras de neg√≥cio complexas)
      await this.paymentService.validatePaymentLimits(accountId, amount);
      
      // Persistir agregado
      await this.paymentRepository.save(payment);
      
      this.logger.info('Payment created successfully', { paymentId: paymentId.value });
      
      // Retornar resultado em formato de apresenta√ß√£o
      return {
        paymentId: payment.id.value,
        status: payment.status,
        amount: payment.amount.amount,
        currency: payment.amount.currency,
      };
      
    } catch (error) {
      this.logger.error('Error creating payment', error);
      throw error;
    }
  }
  
  private generateId(): string {
    return `PAY-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// Outro exemplo: Process Payment Use Case
export interface ProcessPaymentInput {
  paymentId: string;
}

export interface ProcessPaymentOutput {
  paymentId: string;
  status: string;
  message: string;
}

export class ProcessPaymentUseCase {
  constructor(
    private readonly paymentRepository: IPaymentRepository,
    private readonly transactionService: TransactionService,
    private readonly logger: Logger,
  ) {}
  
  async execute(input: ProcessPaymentInput): Promise<ProcessPaymentOutput> {
    // Recuperar agregado do reposit√≥rio
    const payment = await this.paymentRepository.findById(
      new PaymentId(input.paymentId)
    );
    
    if (!payment) {
      throw new Error(`Payment not found: ${input.paymentId}`);
    }
    
    // Criar transa√ß√£o no servi√ßo de transa√ß√µes
    const transaction = await this.transactionService.createTransaction(
      payment.id.value,
      payment.amount
    );
    
    // Adicionar transa√ß√£o ao agregado
    payment.addTransaction(transaction);
    
    // Processar pagamento (comportamento de dom√≠nio)
    payment.process();
    
    // Persistir estado atualizado
    await this.paymentRepository.save(payment);
    
    // Retornar resultado
    return {
      paymentId: payment.id.value,
      status: payment.status,
      message: 'Payment processed successfully',
    };
  }
}
```

---

## 6. SERVICES (Servi√ßos de Dom√≠nio)

### Para uma crian√ßa de 5 anos üßí

Um Service √© como um professor de matem√°tica. Ele n√£o √© um aluno (n√£o √© uma entidade), mas ajuda os alunos a resolver problemas complexos. Se dois alunos precisam trabalhar juntos, o professor fica no meio ajudando. Um Service no software √© assim: n√£o √© um objeto de neg√≥cio, mas ajuda a coordenar e resolver problemas complexos.

### Para um estudante üéì

Um Service de Dom√≠nio encapsula l√≥gica de neg√≥cio que n√£o pertence naturalmente a uma √∫nica Entidade ou Value Object. Quando uma opera√ß√£o envolve m√∫ltiplos agregados ou conceitos do dom√≠nio, um Service coordena essa l√≥gica. Services s√£o stateless, recebem objetos de dom√≠nio como par√¢metros e realizam opera√ß√µes. S√£o diferentes de Application Services que coordenam fluxos; Domain Services expressam conceitos importantes do neg√≥cio.

### Para um programador profissional üë®‚Äçüíº

Domain Services em DDD encapsulam l√≥gica de neg√≥cio que n√£o se encaixa naturalmente no modelo de agregados. Quando uma opera√ß√£o envolve m√∫ltiplos agregados ou quando a l√≥gica √© complexa demais para uma √∫nica entidade, um Domain Service fornece a abstra√ß√£o apropriada. Services s√£o stateless, imut√°veis, e geralmente injetados como depend√™ncias. Application Services, por outro lado, orquestram a aplica√ß√£o usando Domain Services, Repositories e Use Cases.

### Exemplo em TypeScript: Domain Services

```typescript
// Domain Service - l√≥gica de neg√≥cio complexa
export class PaymentService {
  constructor(
    private readonly accountRepository: IAccountRepository,
    private readonly logger: Logger,
  ) {}
  
  // Valida se a conta pode fazer um pagamento deste valor
  async validatePaymentLimits(accountId: AccountId, amount: Money): Promise<void> {
    const account = await this.accountRepository.findById(accountId);
    
    if (!account) {
      throw new Error(`Account not found: ${accountId}`);
    }
    
    // Regra de neg√≥cio: verificar saldo
    if (account.balance.isGreaterThan(amount)) {
      throw new Error('Insufficient balance for this payment');
    }
    
    // Regra de neg√≥cio: verificar limite di√°rio
    const dailyTotal = await this.calculateDailyPaymentTotal(accountId);
    const newTotal = dailyTotal.add(amount);
    
    const dailyLimit = new Money(50000, amount.currency);
    if (newTotal.isGreaterThan(dailyLimit)) {
      throw new Error('Daily payment limit exceeded');
    }
    
    this.logger.info('Payment validation passed', { accountId: accountId.value });
  }
  
  private async calculateDailyPaymentTotal(accountId: AccountId): Promise<Money> {
    // Buscar todos os pagamentos de hoje
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // (implementa√ß√£o dependeria de query ao reposit√≥rio)
    return new Money(0, 'BRL');
  }
}

// Application Service - diferente de Domain Service
// Orquestra os casos de uso
export class PaymentApplicationService {
  constructor(
    private readonly paymentRepository: IPaymentRepository,
    private readonly paymentService: PaymentService,
    private readonly transactionService: TransactionService,
    private readonly notificationService: INotificationService,
  ) {}
  
  async completePaymentWorkflow(payment: Payment): Promise<void> {
    try {
      // Usar Domain Service para valida√ß√µes complexas
      await this.paymentService.validatePaymentLimits(
        payment.accountId,
        payment.amount
      );
      
      // Coordenar m√∫ltiplos agregados
      const transaction = await this.transactionService.createTransaction(
        payment.id.value,
        payment.amount
      );
      
      // Aplicar regras de dom√≠nio
      payment.addTransaction(transaction);
      payment.process();
      
      // Persistir
      await this.paymentRepository.save(payment);
      
      // Notificar externos (infraestrutura)
      await this.notificationService.sendPaymentConfirmation(
        payment.accountId.value,
        payment.amount
      );
      
    } catch (error) {
      this.notificationService.sendPaymentFailure(
        payment.accountId.value,
        error.message
      );
      throw error;
    }
  }
}
```

---

## 7. CONTROLLERS

### Para uma crian√ßa de 5 anos üßí

Um Controller √© como um recepcionista de um consult√≥rio. Quando voc√™ chega, o recepcionista recebe voc√™, anota seus dados, marca o m√©dico certo e depois manda voc√™ para a sala certa. O Controller funciona assim: recebe o pedido do usu√°rio, passa para a pessoa certa (Use Case), e manda a resposta de volta.

### Para um estudante üéì

Um Controller √© o ponto de entrada da aplica√ß√£o que recebe requisi√ß√µes HTTP (ou de outra interface). Sua responsabilidade √© converter dados de entrada em objetos de dom√≠nio, chamar o Use Case apropriado, e converter a resposta para um formato que o cliente entenda. Controllers n√£o cont√™m l√≥gica de neg√≥cio; apenas coordenam entrada, processamento e sa√≠da. Devem ser simples e focados em protocolo HTTP.

### Para um programador profissional üë®‚Äçüíº

Controllers em arquitetura hexagonal atuam como adaptadores da camada de aplica√ß√£o, traduzindo requisi√ß√µes HTTP em chamadas de Use Cases. Respons√°veis por deserializar dados de entrada, valida√ß√£o b√°sica de entrada (formato), invoca√ß√£o do Use Case, tratamento de exce√ß√µes e serializa√ß√£o da resposta. Controllers mant√™m-se agn√≥sticos a detalhes de implementa√ß√£o de dom√≠nio ou persist√™ncia, funcionando como bridges entre o mundo externo (HTTP) e o n√∫cleo da aplica√ß√£o (dom√≠nio).

### Exemplo em TypeScript: Controllers para Pagamentos

```typescript
// Controller - recebe requisi√ß√µes HTTP
export class PaymentController {
  constructor(
    private readonly createPaymentUseCase: CreatePaymentUseCase,
    private readonly processPaymentUseCase: ProcessPaymentUseCase,
    private readonly logger: Logger,
  ) {}
  
  // Criar um novo pagamento
  async create(request: Request, response: Response): Promise<void> {
    try {
      // Valida√ß√£o b√°sica de entrada
      const { accountId, amount, currency } = request.body;
      
      if (!accountId || !amount || !currency) {
        response.status(400).json({
          error: 'Missing required fields: accountId, amount, currency',
        });
        return;
      }
      
      // Chamar Use Case
      const result = await this.createPaymentUseCase.execute({
        accountId,
        amount: parseFloat(amount),
        currency,
      });
      
      // Retornar resposta formatada
      response.status(201).json({
        success: true,
        data: result,
      });
      
    } catch (error) {
      this.logger.error('Error in PaymentController.create', error);
      response.status(500).json({
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  }
  
  // Processar um pagamento existente
  async process(request: Request, response: Response): Promise<void> {
    try {
      const { paymentId } = request.params;
      
      if (!paymentId) {
        response.status(400).json({ error: 'Missing paymentId' });
        return;
      }
      
      // Chamar Use Case
      const result = await this.processPaymentUseCase.execute({ paymentId });
      
      // Retornar resposta
      response.status(200).json({
        success: true,
        data: result,
      });
      
    } catch (error) {
      this.logger.error('Error in PaymentController.process', error);
      response.status(500).json({
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  }
}

// Middleware para logging
export const loggingMiddleware = (req: Request, res: Response, next: Function) => {
  console.log(`${req.method} ${req.path}`);
  next();
};

// Exemplo de rota Express
export function setupPaymentRoutes(
  app: any,
  paymentController: PaymentController
) {
  app.post('/api/payments', (req: Request, res: Response) => 
    paymentController.create(req, res)
  );
  
  app.post('/api/payments/:paymentId/process', (req: Request, res: Response) =>
    paymentController.process(req, res)
  );
}
```

---

## 8. ADAPTERS (Adaptadores)

### Para uma crian√ßa de 5 anos üßí

Um Adapter √© como um transformador de corrente el√©trica. Seu celular precisa de uma corrente espec√≠fica, mas a tomada da casa fornece outra. O adaptador transforma uma em outra, permitindo que tudo funcione. Um Adapter no software faz isso: transforma dados de um formato em outro, permitindo que partes diferentes do sistema trabalhem juntas.

### Para um estudante üéì

Um Adapter √© um padr√£o de design que permite que objetos com interfaces incompat√≠veis trabalhem juntos. Na arquitetura hexagonal, adapters convertem entre o mundo externo (HTTP, bancos de dados, APIs externas) e o dom√≠nio. Existem adapters de entrada (ex: Controllers, que convertem HTTP em Use Cases) e de sa√≠da (ex: Repositories, que convertem dados de dom√≠nio em estruturas de BD). Adapters isolam o dom√≠nio de tecnologias espec√≠ficas.

### Para um programador profissional üë®‚Äçüíº

Adapters em arquitetura hexagonal implementam o padr√£o Adapter, servindo como tradutores entre a camada de aplica√ß√£o e tecnologias externas. Adapters de entrada transformam requisi√ß√µes externas em chamadas de Use Cases; adapters de sa√≠da transformam opera√ß√µes de dom√≠nio em intera√ß√µes com infraestrutura (BD, cache, APIs). Permitem que o dom√≠nio permane√ßa independente de detalhes t√©cnicos, facilitando testes, substitui√ß√£o de tecnologias e evolu√ß√£o arquitetural sem impacto no modelo de neg√≥cio.

### Exemplo em TypeScript: Adapters de Entrada e Sa√≠da

```typescript
// ======== ADAPTERS DE ENTRADA (Input Adapters) ========

// Adapter HTTP para usar Cases de Pagamento
export class HttpPaymentAdapter {
  constructor(
    private readonly createPaymentUseCase: CreatePaymentUseCase,
    private readonly processPaymentUseCase: ProcessPaymentUseCase,
  ) {}
  
  // Converte requisi√ß√£o HTTP em entrada de Use Case
  async handleCreatePayment(httpRequest: any): Promise<any> {
    // Extrair dados da requisi√ß√£o HTTP
    const { body } = httpRequest;
    
    // Chamar Use Case
    const result = await this.createPaymentUseCase.execute({
      accountId: body.accountId,
      amount: body.amount,
      currency: body.currency,
    });
    
    // Converter resultado em resposta HTTP
    return {
      statusCode: 201,
      body: JSON.stringify(result),
      headers: { 'Content-Type': 'application/json' },
    };
  }
}

// Adapter CLI para usar Cases de Pagamento
export class CliPaymentAdapter {
  constructor(
    private readonly createPaymentUseCase: CreatePaymentUseCase,
  ) {}
  
  async handleCreatePayment(args: string[]): Promise<void> {
    try {
      // Parse argumentos de CLI
      const accountId = args[0];
      const amount = parseFloat(args[1]);
      const currency = args[2] || 'BRL';
      
      // Chamar Use Case
      const result = await this.createPaymentUseCase.execute({
        accountId,
        amount,
        currency,
      });
      
      // Output para terminal
      console.log('Payment created:');
      console.log(JSON.stringify(result, null, 2));
      
    } catch (error) {
      console.error('Error:', error instanceof Error ? error.message : error);
    }
  }
}

// ======== ADAPTERS DE SA√çDA (Output Adapters) ========

// Adapter para notifica√ß√µes via Email
export interface INotificationAdapter {
  sendPaymentConfirmation(accountId: string, amount: Money): Promise<void>;
  sendPaymentFailure(accountId: string, reason: string): Promise<void>;
}

export class EmailNotificationAdapter implements INotificationAdapter {
  constructor(private readonly emailService: any) {}
  
  async sendPaymentConfirmation(accountId: string, amount: Money): Promise<void> {
    // Converter dados de dom√≠nio para formato de email
    const emailContent = {
      to: accountId, // Em produ√ß√£o seria um email real
      subject: 'Payment Confirmation',
      body: `Your payment of ${amount.amount} ${amount.currency} has been confirmed.`,
    };
    
    // Chamar servi√ßo de email
    await this.emailService.send(emailContent);
  }
  
  async sendPaymentFailure(accountId: string, reason: string): Promise<void> {
    const emailContent = {
      to: accountId,
      subject: 'Payment Failed',
      body: `Your payment failed: ${reason}`,
    };
    
    await this.emailService.send(emailContent);
  }
}

// Adapter para notifica√ß√µes via SMS
export class SmsNotificationAdapter implements INotificationAdapter {
  constructor(private readonly smsService: any) {}
  
  async sendPaymentConfirmation(accountId: string, amount: Money): Promise<void> {
    const message = `Pagamento confirmado: ${amount.amount} ${amount.currency}`;
    await this.smsService.send(accountId, message);
  }
  
  async sendPaymentFailure(accountId: string, reason: string): Promise<void> {
    const message = `Pagamento falhou: ${reason}`;
    await this.smsService.send(accountId, message);
  }
}

// Adapter para cache Redis
export class RedisCacheAdapter {
  constructor(private readonly redis: any) {}
  
  async getPayment(paymentId: string): Promise<Payment | null> {
    const cached = await this.redis.get(`payment:${paymentId}`);
    
    if (!cached) {
      return null;
    }
    
    // Converter dados em cache de volta para agregado
    const data = JSON.parse(cached);
    return this.reconstructPayment(data);
  }
  
  async setPayment(payment: Payment): Promise<void> {
    // Converter agregado em dados que podem ser cacheados
    const data = {
      id: payment.id.value,
      accountId: payment.accountId.value,
      amount: payment.amount.amount,
      currency: payment.amount.currency,
      status: payment.status,
    };
    
    // Armazenar em cache com TTL de 1 hora
    await this.redis.set(
      `payment:${payment.id.value}`,
      JSON.stringify(data),
      'EX',
      3600
    );
  }
  
  private reconstructPayment(data: any): Payment {
    return new Payment(
      new PaymentId(data.id),
      new AccountId(data.accountId),
      new Money(data.amount, data.currency)
    );
  }
}

// Adapter para persist√™ncia em diferentes bancos
export class MongoPaymentAdapter implements IPaymentRepository {
  constructor(private readonly mongoDb: any) {}
  
  async save(payment: Payment): Promise<void> {
    const document = {
      _id: payment.id.value,
      accountId: payment.accountId.value,
      amount: payment.amount.amount,
      currency: payment.amount.currency,
      status: payment.status,
      transactions: payment.transactions.map(t => ({
        id: t.id.value,
        amount: t.amount.amount,
        currency: t.amount.currency,
        status: t.status,
      })),
      createdAt: payment.createdAt,
      updatedAt: payment.updatedAt,
    };
    
    await this.mongoDb.collection('payments').updateOne(
      { _id: payment.id.value },
      { $set: document },
      { upsert: true }
    );
  }
  
  async findById(id: PaymentId): Promise<Payment | null> {
    const document = await this.mongoDb
      .collection('payments')
      .findOne({ _id: id.value });
    
    if (!document) return null;
    
    // Reconstruir agregado a partir do documento
    return this.reconstructPayment(document);
  }
  
  async delete(id: PaymentId): Promise<void> {
    await this.mongoDb.collection('payments').deleteOne({ _id: id.value });
  }
  
  private reconstructPayment(doc: any): Payment {
    const payment = new Payment(
      new PaymentId(doc._id),
      new AccountId(doc.accountId),
      new Money(doc.amount, doc.currency)
    );
    
    // Restaurar transa√ß√µes
    for (const txDoc of (doc.transactions || [])) {
      const transaction = new Transaction(
        new TransactionId(txDoc.id),
        new Money(txDoc.amount, txDoc.currency),
        txDoc.status
      );
      payment.addTransaction(transaction);
    }
    
    return payment;
  }
}
```

---

## 9. INTERFACES (Contratos)

### Para uma crian√ßa de 5 anos üßí

Uma Interface √© como uma receita de bolo. A receita diz quais ingredientes voc√™ precisa e os passos, mas n√£o diz exatamente qual marca de farinha usar. Qualquer farinha serve, desde que seja farinha. Uma Interface no software √© assim: define quais m√©todos um objeto deve ter, mas cada um pode implementar de um jeito diferente.

### Para um estudante üéì

Uma Interface define um contrato que especifica quais m√©todos um objeto deve ter, sem definir como implement√°-los. Interfaces permitem que diferentes implementa√ß√µes satisfa√ßam o mesmo contrato. Em TypeScript, s√£o declaradas com a palavra-chave `interface`. Usar interfaces promove desacoplamento: c√≥digo depende de abstra√ß√µes (interfaces) em vez de implementa√ß√µes concretas, facilitando testes (com mocks) e mudan√ßas de implementa√ß√£o.

### Para um programador profissional üë®‚Äçüíº

Interfaces em TypeScript definem contratos expl√≠citos que classes devem satisfazer, promovendo design orientado a contratos. Fundamentais para Inje√ß√£o de Depend√™ncia e padr√µes de design como Adapter, Strategy e Factory. Permitem que camadas externas dependam de abstra√ß√µes em vez de implementa√ß√µes, habilitando m√∫ltiplas implementa√ß√µes (ex: Repository para SQL, NoSQL, In-Memory) sem afetar consumidores. Essenciais para testabilidade e manutenibilidade em arquitetura hexagonal.

### Exemplo em TypeScript: Interfaces e Contratos

```typescript
// ======== INTERFACES DE REPOSIT√ìRIO ========

// Contrato para persist√™ncia de pagamentos
export interface IPaymentRepository {
  save(payment: Payment): Promise<void>;
  findById(id: PaymentId): Promise<Payment | null>;
  delete(id: PaymentId): Promise<void>;
  findByAccountId(accountId: AccountId): Promise<Payment[]>;
}

// Contrato para persist√™ncia de contas
export interface IAccountRepository {
  save(account: Account): Promise<void>;
  findById(id: AccountId): Promise<Account | null>;
  findByEmail(email: Email): Promise<Account | null>;
}

// ======== INTERFACES DE SERVI√áOS ========

// Contrato para servi√ßo de notifica√ß√µes
export interface INotificationService {
  sendPaymentConfirmation(accountId: string, amount: Money): Promise<void>;
  sendPaymentFailure(accountId: string, reason: string): Promise<void>;
}

// Contrato para servi√ßo de transa√ß√µes
export interface ITransactionService {
  createTransaction(paymentId: string, amount: Money): Promise<Transaction>;
  verifyTransaction(transactionId: string): Promise<boolean>;
}

// Contrato para servi√ßo de cache
export interface ICacheService {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
}

// ======== INTERFACES DE LOGGER ========

export interface ILogger {
  info(message: string, meta?: any): void;
  error(message: string, error?: any): void;
  warn(message: string, meta?: any): void;
}

// ======== INTERFACES DE IDENTIFICADORES ========

export interface IIdentifier {
  value: string;
  equals(other: IIdentifier): boolean;
}

// ======== EXEMPLO: USE CASE COM INJE√á√ÉO VIA INTERFACES ========

export class CreatePaymentUseCase {
  constructor(
    private readonly paymentRepository: IPaymentRepository, // Depende da interface
    private readonly transactionService: ITransactionService,
    private readonly cacheService: ICacheService,
    private readonly logger: ILogger,
  ) {}
  
  async execute(input: CreatePaymentInput): Promise<CreatePaymentOutput> {
    try {
      // Qualquer implementa√ß√£o de IPaymentRepository funciona aqui
      // Pode ser SQL, MongoDB, ou In-Memory para testes
      
      const paymentId = new PaymentId(this.generateId());
      const payment = new Payment(
        paymentId,
        new AccountId(input.accountId),
        new Money(input.amount, input.currency)
      );
      
      // Usar a interface abstrata
      await this.paymentRepository.save(payment);
      
      // Invalidar cache (qualquer implementa√ß√£o serve)
      await this.cacheService.delete(`payments:${input.accountId}`);
      
      return {
        paymentId: payment.id.value,
        status: payment.status,
        amount: payment.amount.amount,
        currency: payment.amount.currency,
      };
      
    } catch (error) {
      this.logger.error('Error creating payment', error);
      throw error;
    }
  }
  
  private generateId(): string {
    return `PAY-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ======== EXEMPLO: TESTES COM MOCKS ========

// Implementa√ß√£o mock para testes
class MockPaymentRepository implements IPaymentRepository {
  private payments: Map<string, Payment> = new Map();
  
  async save(payment: Payment): Promise<void> {
    this.payments.set(payment.id.value, payment);
  }
  
  async findById(id: PaymentId): Promise<Payment | null> {
    return this.payments.get(id.value) || null;
  }
  
  async delete(id: PaymentId): Promise<void> {
    this.payments.delete(id.value);
  }
  
  async findByAccountId(accountId: AccountId): Promise<Payment[]> {
    return Array.from(this.payments.values())
      .filter(p => p.accountId.equals(accountId));
  }
}

class MockCacheService implements ICacheService {
  private cache: Map<string, any> = new Map();
  
  async get<T>(key: string): Promise<T | null> {
    return this.cache.get(key) || null;
  }
  
  async set<T>(key: string, value: T): Promise<void> {
    this.cache.set(key, value);
  }
  
  async delete(key: string): Promise<void> {
    this.cache.delete(key);
  }
}

// Teste usando mocks
async function testCreatePayment() {
  const mockRepository = new MockPaymentRepository();
  const mockCache = new MockCacheService();
  const mockLogger = { info: console.log, error: console.error, warn: console.warn };
  const mockTransaction = { createTransaction: async () => ({ /* ... */ }) };
  
  const useCase = new CreatePaymentUseCase(
    mockRepository,
    mockTransaction as any,
    mockCache,
    mockLogger as any
  );
  
  const result = await useCase.execute({
    accountId: 'ACC-123',
    amount: 100,
    currency: 'BRL',
  });
  
  console.log('Test passed:', result);
}
```

---

## üìä DIAGRAMA GERAL: ARQUITETURA HEXAGONAL COM DDD

```plaintext
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     CAMADA DE APRESENTA√á√ÉO                      ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ  ‚îÇ  HTTP REST  ‚îÇ  ‚îÇ     CLI      ‚îÇ  ‚îÇ   GraphQL    ‚îÇ            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                  ‚îÇ                ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ    ADAPTERS DE ENTRADA (Input)       ‚îÇ
          ‚îÇ    Controllers / CLI Adapters        ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           CAMADA DE APLICA√á√ÉO (Application Layer)              ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ              USE CASES / Application Services            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ CreatePayment‚îÇ  ‚îÇProcessPayment‚îÇ  ‚îÇ CancelPayment‚îÇ    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                             ‚îÇ                                  ‚îÇ
‚îÇ                    Orquestra e coordena                        ‚îÇ
‚îÇ                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              CAMADA DE DOM√çNIO (Domain Layer)                  ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                    AGREGADOS                             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ           Payment Aggregate                      ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                                                   ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ Payment (Aggregate Root / Entity)           ‚îÇ ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ ‚Ä¢ _id: PaymentId (Value Object)             ‚îÇ ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ ‚Ä¢ _amount: Money (Value Object)             ‚îÇ ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ ‚Ä¢ _status: TransactionStatus (Value Object) ‚îÇ ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ ‚Ä¢ _transactions: Transaction[] (Entities)   ‚îÇ ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                                                   ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ          Transaction (Entity)                    ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚Ä¢ _id: TransactionId (Value Object)             ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚Ä¢ _amount: Money (Value Object)                 ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                                                           ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ              SERVI√áOS DE DOM√çNIO                          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  PaymentService  ‚îÇ  ‚îÇ  AccountService  ‚îÇ             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ              INTERFACES / CONTRATOS                       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  IPaymentRepository  ‚îÇ  INotificationService             ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ                  ‚îÇ                ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ADAPTERS DE      ‚îÇ ‚îÇ   ADAPTERS    ‚îÇ ‚îÇ  ADAPTERS        ‚îÇ
‚îÇ  SA√çDA            ‚îÇ ‚îÇ   DE          ‚îÇ ‚îÇ  EXTERNOS        ‚îÇ
‚îÇ  (Output)         ‚îÇ ‚îÇ   PERSIST√äNCIA ‚îÇ ‚îÇ                 ‚îÇ
‚îÇ                   ‚îÇ ‚îÇ                ‚îÇ ‚îÇ                 ‚îÇ
‚îÇ ‚Ä¢ Notification    ‚îÇ ‚îÇ ‚Ä¢ SQL Database ‚îÇ ‚îÇ ‚Ä¢ Email Service ‚îÇ
‚îÇ   (Email/SMS)     ‚îÇ ‚îÇ ‚Ä¢ MongoDB      ‚îÇ ‚îÇ ‚Ä¢ Payment API   ‚îÇ
‚îÇ ‚Ä¢ Logger          ‚îÇ ‚îÇ ‚Ä¢ Cache Redis  ‚îÇ ‚îÇ ‚Ä¢ Message Queue ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## FLUXO DE UMA REQUISI√á√ÉO

```plaintext
1. CLIENTE faz requisi√ß√£o HTTP
   POST /api/payments
   { "accountId": "ACC-123", "amount": 100, "currency": "BRL" }
   ‚îÇ
   ‚ñº
2. CONTROLLER recebe requisi√ß√£o
   PaymentController.create(request)
   ‚îÇ
   ‚îú‚îÄ Valida√ß√£o b√°sica (formato HTTP)
   ‚îú‚îÄ Extrai dados: accountId, amount, currency
   ‚îÇ
   ‚ñº
3. USA CASE √© executado
   CreatePaymentUseCase.execute({...})
   ‚îÇ
   ‚îú‚îÄ Cria Value Objects: Money, PaymentId, AccountId
   ‚îú‚îÄ Instancia Agregado: Payment
   ‚îú‚îÄ Usa DOMAIN SERVICE para valida√ß√µes complexas
   ‚îÇ  (ex: PaymentService.validatePaymentLimits)
   ‚îú‚îÄ Persiste usando REPOSITORY
   ‚îÇ  PaymentRepository.save(payment)
   ‚îÇ
   ‚ñº
4. REPOSITORY (Adapter de Sa√≠da) persiste
   PaymentRepositorySQL.save(payment)
   ‚îÇ
   ‚îú‚îÄ Converte agregado para estrutura de dados
   ‚îú‚îÄ Executa queries SQL
   ‚îú‚îÄ Insere em banco de dados
   ‚îÇ
   ‚ñº
5. SERVI√áOS DE INFRAESTRUTURA s√£o chamados
   NotificationAdapter.sendConfirmation(...)
   ‚îÇ
   ‚îú‚îÄ Converte dados de dom√≠nio para formato externo
   ‚îú‚îÄ Envia email/SMS/notifica√ß√£o
   ‚îÇ
   ‚ñº
6. RESPOSTA retorna ao CONTROLLER
   CreatePaymentOutput {paymentId, status, amount, currency}
   ‚îÇ
   ‚îú‚îÄ Controller serializa para JSON
   ‚îú‚îÄ Retorna HTTP 201
   ‚îÇ
   ‚ñº
7. CLIENTE recebe resposta
   { "paymentId": "PAY-...", "status": "PENDING", ... }
```

---

## ESTRUTURA DE PASTAS RECOMENDADA

```plaintext
projeto-pagamentos/
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ domain/                           ‚Üê N√öCLEO DO NEG√ìCIO
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Payment.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Transaction.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Account.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ value-objects/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Money.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Email.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentId.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AccountId.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ aggregates/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaymentAggregate.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentService.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AccountService.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IPaymentRepository.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ INotificationService.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ICacheService.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ events/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PaymentCreatedEvent.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PaymentCompletedEvent.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ application/                      ‚Üê COORDENA√á√ÉO
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ use-cases/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreatePaymentUseCase.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProcessPaymentUseCase.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CancelPaymentUseCase.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dtos/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreatePaymentInput.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreatePaymentOutput.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PaymentApplicationService.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ adapters/                         ‚Üê INTERFACES EXTERNAS
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ http/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentController.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ persistence/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentRepositorySQL.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentRepositoryMongo.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaymentRepositoryMemory.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ notifications/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EmailNotificationAdapter.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SmsNotificationAdapter.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RedisCacheAdapter.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InMemoryCacheAdapter.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaymentCliAdapter.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ external-services/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PaymentGatewayAdapter.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ BankingApiAdapter.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/                   ‚Üê IMPLEMENTA√á√ïES
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connection.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migrations/
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ redisClient.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Logger.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ di/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ container.ts               ‚Üê Inje√ß√£o de Depend√™ncia
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ env.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ main.ts                           ‚Üê Entrada da aplica√ß√£o
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Payment.spec.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Money.spec.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaymentService.spec.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreatePaymentUseCase.spec.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProcessPaymentUseCase.spec.ts
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ adapters/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PaymentController.spec.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ payment-workflow.spec.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/
‚îÇ       ‚îú‚îÄ‚îÄ payment.fixture.ts
‚îÇ       ‚îî‚îÄ‚îÄ mock-repositories.ts
‚îÇ
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ README.md
```

---

## EXEMPLO COMPLETO: CRIAR E PROCESSAR PAGAMENTO

```typescript
// ========================================
// 1. DOM√çNIO - Defini√ß√£o dos agregados
// ========================================

// domain/value-objects/Money.ts
export class Money {
  constructor(
    private readonly _amount: number,
    private readonly _currency: string = 'BRL'
  ) {
    if (_amount < 0) throw new Error('Amount cannot be negative');
  }
  
  get amount(): number { return this._amount; }
  get currency(): string { return this._currency; }
  
  add(other: Money): Money {
    if (this._currency !== other._currency) 
      throw new Error('Cannot add different currencies');
    return new Money(this._amount + other._amount, this._currency);
  }
  
  equals(other: Money): boolean {
    return this._amount === other._amount && 
           this._currency === other._currency;
  }
}

// domain/value-objects/PaymentId.ts
export class PaymentId {
  constructor(private readonly _value: string) {
    if (!_value) throw new Error('PaymentId required');
  }
  
  get value(): string { return this._value; }
  
  equals(other: PaymentId): boolean {
    return this._value === other._value;
  }
}

// domain/entities/Transaction.ts
export class Transaction {
  private _status: TransactionStatus = TransactionStatus.PENDING;
  
  constructor(
    private readonly _id: TransactionId,
    private readonly _amount: Money
  ) {}
  
  get id(): TransactionId { return this._id; }
  get amount(): Money { return this._amount; }
  get status(): TransactionStatus { return this._status; }
  
  approve(): void {
    if (this._status !== TransactionStatus.PENDING)
      throw new Error('Only pending transactions can be approved');
    this._status = TransactionStatus.APPROVED;
  }
  
  equals(other: Transaction): boolean {
    return this._id.equals(other._id);
  }
}

// domain/entities/Payment.ts (Aggregate Root)
export enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  COMPLETED = 'COMPLETED',
  REJECTED = 'REJECTED'
}

export class Payment {
  private _status: PaymentStatus = PaymentStatus.PENDING;
  private readonly _transactions: Transaction[] = [];
  
  constructor(
    private readonly _id: PaymentId,
    private readonly _accountId: string,
    private readonly _amount: Money
  ) {}
  
  get id(): PaymentId { return this._id; }
  get accountId(): string { return this._accountId; }
  get amount(): Money { return this._amount; }
  get status(): PaymentStatus { return this._status; }
  get transactions(): ReadonlyArray<Transaction> { 
    return Object.freeze([...this._transactions]); 
  }
  
  addTransaction(transaction: Transaction): void {
    if (this._status !== PaymentStatus.PENDING)
      throw new Error('Cannot add transaction to non-pending payment');
    if (this._transactions.some(t => t.equals(transaction)))
      throw new Error('Transaction already exists');
    this._transactions.push(transaction);
  }
  
  process(): void {
    if (this._transactions.length === 0)
      throw new Error('Cannot process without transactions');
    this._status = PaymentStatus.PROCESSING;
  }
  
  complete(): void {
    const allApproved = this._transactions.every(
      t => t.status === TransactionStatus.APPROVED
    );
    if (!allApproved)
      throw new Error('Not all transactions approved');
    this._status = PaymentStatus.COMPLETED;
  }
  
  reject(): void {
    if (this._status === PaymentStatus.COMPLETED ||
        this._status === PaymentStatus.REJECTED)
      throw new Error('Cannot reject completed or rejected payment');
    this._status = PaymentStatus.REJECTED;
  }
  
  equals(other: Payment): boolean {
    return this._id.equals(other._id);
  }
}

// ========================================
// 2. DOM√çNIO - Interfaces de contrato
// ========================================

// domain/interfaces/IPaymentRepository.ts
export interface IPaymentRepository {
  save(payment: Payment): Promise<void>;
  findById(id: PaymentId): Promise<Payment | null>;
}

// domain/interfaces/ITransactionService.ts
export interface ITransactionService {
  createTransaction(amount: Money): Promise<Transaction>;
}

// domain/interfaces/INotificationService.ts
export interface INotificationService {
  sendPaymentCreated(accountId: string, paymentId: string): Promise<void>;
  sendPaymentCompleted(accountId: string, amount: Money): Promise<void>;
}

// ========================================
// 3. DOM√çNIO - Servi√ßos de dom√≠nio
// ========================================

// domain/services/PaymentService.ts
export class PaymentService {
  constructor(private readonly accountService: any) {}
  
  async validatePaymentLimits(accountId: string, amount: Money): Promise<void> {
    const account = await this.accountService.getAccount(accountId);
    
    if (!account) throw new Error('Account not found');
    if (amount.amount > account.balance)
      throw new Error('Insufficient balance');
      
    // Validar limite di√°rio
    const dailyTotal = await this.accountService.getDailyTotal(accountId);
    const limit = new Money(50000, amount.currency);
    
    if (dailyTotal.add(amount).amount > limit.amount)
      throw new Error('Daily limit exceeded');
  }
}

// ========================================
// 4. APLICA√á√ÉO - Use Cases
// ========================================

// application/use-cases/CreatePaymentUseCase.ts
export interface CreatePaymentInput {
  accountId: string;
  amount: number;
  currency: string;
}

export interface CreatePaymentOutput {
  paymentId: string;
  status: string;
  amount: number;
  currency: string;
}

export class CreatePaymentUseCase {
  constructor(
    private readonly paymentRepository: IPaymentRepository,
    private readonly paymentService: PaymentService,
    private readonly notificationService: INotificationService
  ) {}
  
  async execute(input: CreatePaymentInput): Promise<CreatePaymentOutput> {
    // Valida√ß√£o b√°sica
    if (!input.accountId || input.amount <= 0)
      throw new Error('Invalid input');
    
    // Criar Value Objects
    const paymentId = new PaymentId(this.generateId());
    const amount = new Money(input.amount, input.currency);
    
    // Validar regras de neg√≥cio
    await this.paymentService.validatePaymentLimits(input.accountId, amount);
    
    // Criar agregado
    const payment = new Payment(paymentId, input.accountId, amount);
    
    // Persistir
    await this.paymentRepository.save(payment);
    
    // Notificar
    await this.notificationService.sendPaymentCreated(
      input.accountId,
      paymentId.value
    );
    
    return {
      paymentId: payment.id.value,
      status: payment.status,
      amount: payment.amount.amount,
      currency: payment.amount.currency
    };
  }
  
  private generateId(): string {
    return `PAY-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// application/use-cases/ProcessPaymentUseCase.ts
export interface ProcessPaymentInput {
  paymentId: string;
}

export interface ProcessPaymentOutput {
  paymentId: string;
  status: string;
  message: string;
}

export class ProcessPaymentUseCase {
  constructor(
    private readonly paymentRepository: IPaymentRepository,
    private readonly transactionService: ITransactionService,
    private readonly notificationService: INotificationService
  ) {}
  
  async execute(input: ProcessPaymentInput): Promise<ProcessPaymentOutput> {
    // Recuperar agregado
    const payment = await this.paymentRepository.findById(
      new PaymentId(input.paymentId)
    );
    
    if (!payment) throw new Error('Payment not found');
    
    // Criar transa√ß√£o
    const transaction = await this.transactionService.createTransaction(
      payment.amount
    );
    
    // Adicionar ao agregado
    payment.addTransaction(transaction);
    
    // Processar (comportamento de dom√≠nio)
    payment.process();
    
    // Simular processamento externo
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Aprovar transa√ß√£o
    transaction.approve();
    
    // Completar pagamento
    payment.complete();
    
    // Persistir
    await this.paymentRepository.save(payment);
    
    // Notificar
    await this.notificationService.sendPaymentCompleted(
      payment.accountId,
      payment.amount
    );
    
    return {
      paymentId: payment.id.value,
      status: payment.status,
      message: 'Payment processed successfully'
    };
  }
}

// ========================================
// 5. ADAPTADORES - Controllers HTTP
// ========================================

// adapters/http/PaymentController.ts
export class PaymentController {
  constructor(
    private readonly createPaymentUseCase: CreatePaymentUseCase,
    private readonly processPaymentUseCase: ProcessPaymentUseCase
  ) {}
  
  async create(request: Request, response: Response): Promise<void> {
    try {
      const { accountId, amount, currency } = request.body;
      
      const result = await this.createPaymentUseCase.execute({
        accountId,
        amount: parseFloat(amount),
        currency
      });
      
      response.status(201).json({
        success: true,
        data: result
      });
      
    } catch (error) {
      response.status(400).json({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
  
  async process(request: Request, response: Response): Promise<void> {
    try {
      const { paymentId } = request.params;
      
      const result = await this.processPaymentUseCase.execute({ paymentId });
      
      response.status(200).json({
        success: true,
        data: result
      });
      
    } catch (error) {
      response.status(400).json({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
}

// ========================================
// 6. ADAPTADORES - Reposit√≥rios
// ========================================

// adapters/persistence/PaymentRepositoryMemory.ts
export class PaymentRepositoryMemory implements IPaymentRepository {
  private payments: Map<string, Payment> = new Map();
  
  async save(payment: Payment): Promise<void> {
    this.payments.set(payment.id.value, payment);
  }
  
  async findById(id: PaymentId): Promise<Payment | null> {
    return this.payments.get(id.value) || null;
  }
}

// adapters/notifications/ConsoleNotificationAdapter.ts
export class ConsoleNotificationAdapter implements INotificationService {
  async sendPaymentCreated(accountId: string, paymentId: string): Promise<void> {
    console.log(`‚úÖ Payment created for account ${accountId}: ${paymentId}`);
  }
  
  async sendPaymentCompleted(accountId: string, amount: Money): Promise<void> {
    console.log(
      `‚úÖ Payment completed for account ${accountId}: ${amount.amount} ${amount.currency}`
    );
  }
}

// ========================================
// 7. INJE√á√ÉO DE DEPEND√äNCIA
// ========================================

// infrastructure/di/container.ts
export class Container {
  static createPaymentUseCases() {
    // Criar adapters e reposit√≥rios
    const paymentRepository = new PaymentRepositoryMemory();
    const notificationService = new ConsoleNotificationAdapter();
    const transactionService = new SimpleTransactionService();
    const accountService = new SimpleAccountService();
    
    // Criar servi√ßos de dom√≠nio
    const paymentService = new PaymentService(accountService);
    
    // Criar use cases
    const createPaymentUseCase = new CreatePaymentUseCase(
      paymentRepository,
      paymentService,
      notificationService
    );
    
    const processPaymentUseCase = new ProcessPaymentUseCase(
      paymentRepository,
      transactionService,
      notificationService
    );
    
    return { createPaymentUseCase, processPaymentUseCase };
  }
  
  static createController() {
    const { createPaymentUseCase, processPaymentUseCase } = 
      this.createPaymentUseCases();
    
    return new PaymentController(createPaymentUseCase, processPaymentUseCase);
  }
}

// ========================================
// 8. EXECUTANDO O FLUXO COMPLETO
// ========================================

async function demonstrateFlow() {
  console.log('=== Payment Processing Flow ===\n');
  
  const { createPaymentUseCase, processPaymentUseCase } = 
    Container.createPaymentUseCases();
  
  // 1. Criar pagamento
  console.log('1Ô∏è‚É£ Creating payment...');
  const createResult = await createPaymentUseCase.execute({
    accountId: 'ACC-001',
    amount: 100.00,
    currency: 'BRL'
  });
  console.log('Result:', createResult);
  
  // 2. Processar pagamento
  console.log('\n2Ô∏è‚É£ Processing payment...');
  const processResult = await processPaymentUseCase.execute({
    paymentId: createResult.paymentId
  });
  console.log('Result:', processResult);
  
  console.log('\n‚úÖ Flow completed successfully!');
}

// Executar
demonstrateFlow().catch(console.error);
```

---

## üß™ TESTES UNIT√ÅRIOS COM MOCKS

```typescript
// tests/unit/application/CreatePaymentUseCase.spec.ts

describe('CreatePaymentUseCase', () => {
  let useCase: CreatePaymentUseCase;
  let mockRepository: MockPaymentRepository;
  let mockPaymentService: MockPaymentService;
  let mockNotificationService: MockNotificationService;
  
  beforeEach(() => {
    mockRepository = new MockPaymentRepository();
    mockPaymentService = new MockPaymentService();
    mockNotificationService = new MockNotificationService();
    
    useCase = new CreatePaymentUseCase(
      mockRepository,
      mockPaymentService,
      mockNotificationService
    );
  });
  
  it('should create a payment successfully', async () => {
    const input: CreatePaymentInput = {
      accountId: 'ACC-001',
      amount: 100,
      currency: 'BRL'
    };
    
    const result = await useCase.execute(input);
    
    expect(result.paymentId).toBeDefined();
    expect(result.status).toBe('PENDING');
    expect(result.amount).toBe(100);
    
    // Verificar que foi persistido
    const saved = await mockRepository.findById(new PaymentId(result.paymentId));
    expect(saved).not.toBeNull();
  });
  
  it('should throw error for invalid amount', async () => {
    const input: CreatePaymentInput = {
      accountId: 'ACC-001',
      amount: -100,
      currency: 'BRL'
    };
    
    await expect(useCase.execute(input)).rejects.toThrow();
  });
  
  it('should validate payment limits', async () => {
    mockPaymentService.shouldThrow = true;
    
    const input: CreatePaymentInput = {
      accountId: 'ACC-001',
      amount: 100000,
      currency: 'BRL'
    };
    
    await expect(useCase.execute(input)).rejects.toThrow();
  });
  
  it('should send notification on creation', async () => {
    const input: CreatePaymentInput = {
      accountId: 'ACC-001',
      amount: 100,
      currency: 'BRL'
    };
    
    await useCase.execute(input);
    
    expect(mockNotificationService.notificationsSent).toBe(1);
  });
});

// Mock implementations
class MockPaymentRepository implements IPaymentRepository {
  private payments = new Map<string, Payment>();
  
  async save(payment: Payment): Promise<void> {
    this.payments.set(payment.id.value, payment);
  }
  
  async findById(id: PaymentId): Promise<Payment | null> {
    return this.payments.get(id.value) || null;
  }
}

class MockPaymentService {
  shouldThrow = false;
  
  async validatePaymentLimits(accountId: string, amount: Money): Promise<void> {
    if (this.shouldThrow) {
      throw new Error('Validation failed');
    }
  }
}

class MockNotificationService implements INotificationService {
  notificationsSent = 0;
  
  async sendPaymentCreated(accountId: string, paymentId: string): Promise<void> {
    this.notificationsSent++;
  }
  
  async sendPaymentCompleted(accountId: string, amount: Money): Promise<void> {
    this.notificationsSent++;
  }
}
```

---

## RESUMO: COMO OS CONCEITOS TRABALHAM JUNTOS

| Conceito           | Responsabilidade                 | Exemplos                                       |
| ------------------ | -------------------------------- | ---------------------------------------------- |
| **Entity**         | Identidade √∫nica e comportamento | Payment, Transaction, Account                  |
| **Value Object**   | Imutabilidade e valida√ß√£o        | Money, Email, PaymentId                        |
| **Aggregate**      | Consist√™ncia transacional        | PaymentAggregate cont√©m Payment + Transactions |
| **Repository**     | Abstra√ß√£o de persist√™ncia        | IPaymentRepository, SQLRepository              |
| **Use Case**       | Orquestra√ß√£o de fluxo            | CreatePayment, ProcessPayment                  |
| **Domain Service** | L√≥gica complexa multi-agregado   | PaymentService.validateLimits                  |
| **Controller**     | Interface HTTP                   | PaymentController.create()                     |
| **Adapter**        | Tradu√ß√£o de tecnologias          | SQLAdapter, EmailAdapter, RedisAdapter         |
| **Interface**      | Contrato e desacoplamento        | IRepository, IService, IAdapter                |

---

## BENEF√çCIOS DESSA ARQUITETURA

```plaintext
DDD + Arquitetura Hexagonal
    ‚îÇ
    ‚îú‚îÄ ‚úÖ Dom√≠nio independente de tecnologia
    ‚îÇ   ‚îî‚îÄ F√°cil trocar banco de dados, frameworks, etc.
    ‚îÇ
    ‚îú‚îÄ ‚úÖ Testabilidade
    ‚îÇ   ‚îî‚îÄ Use mocks, testes isolados, sem depend√™ncias externas
    ‚îÇ
    ‚îú‚îÄ ‚úÖ Manutenibilidade
    ‚îÇ   ‚îî‚îÄ C√≥digo organizado, responsabilidades claras
    ‚îÇ
    ‚îú‚îÄ ‚úÖ Evolu√ß√£o
    ‚îÇ   ‚îî‚îÄ Adicionar features sem quebrar existentes
    ‚îÇ
    ‚îú‚îÄ ‚úÖ Escalabilidade
    ‚îÇ   ‚îî‚îÄ Estrutura suporta crescimento do projeto
    ‚îÇ
    ‚îú‚îÄ ‚úÖ Comunica√ß√£o com neg√≥cio
    ‚îÇ   ‚îî‚îÄ Linguagem ub√≠qua, c√≥digo reflete regras de neg√≥cio
    ‚îÇ
    ‚îî‚îÄ ‚úÖ Reusabilidade
        ‚îî‚îÄ Use Cases reutiliz√°veis em diferentes interfaces
```

---

## üìö REFER√äNCIAS E PR√ìXIMOS PASSOS

### Conceitos avan√ßados a explorar

- **Event Sourcing**: Armazenar eventos do dom√≠nio em vez de estado
- **CQRS**: Separar commands (escrita) de queries (leitura)
- **Domain Events**: Eventos criados pelo agregado para notificar mudan√ßas
- **Bounded Contexts**: Separar m√∫ltiplos modelos de dom√≠nio
- **Anti-Corruption Layer**: Traduzir entre diferentes bounded contexts

### Padr√µes complementares

- **Factory Pattern**: Criar agregados complexos
- **Strategy Pattern**: Diferentes implementa√ß√µes de servi√ßos
- **Observer Pattern**: Reagir a eventos de dom√≠nio
- **Decorator Pattern**: Adicionar comportamentos a objetos

---

## CONCLUS√ÉO

A arquitetura DDD com Hexagonal proporciona uma forma estruturada e escal√°vel de construir aplica√ß√µes. Os conceitos trabalham em harmonia:

1. **Value Objects e Entities** formam o vocabul√°rio do dom√≠nio
2. **Agregados** garantem consist√™ncia
3. **Repositories** abstraem persist√™ncia
4. **Use Cases** orquestram fluxos
5. **Domain Services** encapsulam l√≥gica complexa
6. **Controllers** recebem requisi√ß√µes
7. **Adapters** traduzem tecnologias
8. **Interfaces** permitem desacoplamento

Esse design torna sua aplica√ß√£o **robusta**, **test√°vel** e **pronta para evoluir**!
